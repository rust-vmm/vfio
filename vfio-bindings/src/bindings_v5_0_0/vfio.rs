/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const VFIO_API_VERSION: u32 = 0;
pub const VFIO_TYPE1_IOMMU: u32 = 1;
pub const VFIO_SPAPR_TCE_IOMMU: u32 = 2;
pub const VFIO_TYPE1v2_IOMMU: u32 = 3;
pub const VFIO_DMA_CC_IOMMU: u32 = 4;
pub const VFIO_EEH: u32 = 5;
pub const VFIO_TYPE1_NESTING_IOMMU: u32 = 6;
pub const VFIO_SPAPR_TCE_v2_IOMMU: u32 = 7;
pub const VFIO_NOIOMMU_IOMMU: u32 = 8;
pub const VFIO_TYPE: u32 = 59;
pub const VFIO_BASE: u32 = 100;
pub const VFIO_GROUP_FLAGS_VIABLE: u32 = 1;
pub const VFIO_GROUP_FLAGS_CONTAINER_SET: u32 = 2;
pub const VFIO_DEVICE_FLAGS_RESET: u32 = 1;
pub const VFIO_DEVICE_FLAGS_PCI: u32 = 2;
pub const VFIO_DEVICE_FLAGS_PLATFORM: u32 = 4;
pub const VFIO_DEVICE_FLAGS_AMBA: u32 = 8;
pub const VFIO_DEVICE_FLAGS_CCW: u32 = 16;
pub const VFIO_DEVICE_FLAGS_AP: u32 = 32;
pub const VFIO_DEVICE_API_PCI_STRING: &[u8; 9] = b"vfio-pci\0";
pub const VFIO_DEVICE_API_PLATFORM_STRING: &[u8; 14] = b"vfio-platform\0";
pub const VFIO_DEVICE_API_AMBA_STRING: &[u8; 10] = b"vfio-amba\0";
pub const VFIO_DEVICE_API_CCW_STRING: &[u8; 9] = b"vfio-ccw\0";
pub const VFIO_DEVICE_API_AP_STRING: &[u8; 8] = b"vfio-ap\0";
pub const VFIO_REGION_INFO_FLAG_READ: u32 = 1;
pub const VFIO_REGION_INFO_FLAG_WRITE: u32 = 2;
pub const VFIO_REGION_INFO_FLAG_MMAP: u32 = 4;
pub const VFIO_REGION_INFO_FLAG_CAPS: u32 = 8;
pub const VFIO_REGION_INFO_CAP_SPARSE_MMAP: u32 = 1;
pub const VFIO_REGION_INFO_CAP_TYPE: u32 = 2;
pub const VFIO_REGION_TYPE_PCI_VENDOR_TYPE: u32 = 2147483648;
pub const VFIO_REGION_TYPE_PCI_VENDOR_MASK: u32 = 65535;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION: u32 = 1;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_HOST_CFG: u32 = 2;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_LPC_CFG: u32 = 3;
pub const VFIO_REGION_TYPE_GFX: u32 = 1;
pub const VFIO_REGION_SUBTYPE_GFX_EDID: u32 = 1;
pub const VFIO_DEVICE_GFX_LINK_STATE_UP: u32 = 1;
pub const VFIO_DEVICE_GFX_LINK_STATE_DOWN: u32 = 2;
pub const VFIO_REGION_SUBTYPE_NVIDIA_NVLINK2_RAM: u32 = 1;
pub const VFIO_REGION_SUBTYPE_IBM_NVLINK2_ATSD: u32 = 1;
pub const VFIO_REGION_INFO_CAP_MSIX_MAPPABLE: u32 = 3;
pub const VFIO_REGION_INFO_CAP_NVLINK2_SSATGT: u32 = 4;
pub const VFIO_REGION_INFO_CAP_NVLINK2_LNKSPD: u32 = 5;
pub const VFIO_IRQ_INFO_EVENTFD: u32 = 1;
pub const VFIO_IRQ_INFO_MASKABLE: u32 = 2;
pub const VFIO_IRQ_INFO_AUTOMASKED: u32 = 4;
pub const VFIO_IRQ_INFO_NORESIZE: u32 = 8;
pub const VFIO_IRQ_SET_DATA_NONE: u32 = 1;
pub const VFIO_IRQ_SET_DATA_BOOL: u32 = 2;
pub const VFIO_IRQ_SET_DATA_EVENTFD: u32 = 4;
pub const VFIO_IRQ_SET_ACTION_MASK: u32 = 8;
pub const VFIO_IRQ_SET_ACTION_UNMASK: u32 = 16;
pub const VFIO_IRQ_SET_ACTION_TRIGGER: u32 = 32;
pub const VFIO_IRQ_SET_DATA_TYPE_MASK: u32 = 7;
pub const VFIO_IRQ_SET_ACTION_TYPE_MASK: u32 = 56;
pub const VFIO_GFX_PLANE_TYPE_PROBE: u32 = 1;
pub const VFIO_GFX_PLANE_TYPE_DMABUF: u32 = 2;
pub const VFIO_GFX_PLANE_TYPE_REGION: u32 = 4;
pub const VFIO_DEVICE_IOEVENTFD_8: u32 = 1;
pub const VFIO_DEVICE_IOEVENTFD_16: u32 = 2;
pub const VFIO_DEVICE_IOEVENTFD_32: u32 = 4;
pub const VFIO_DEVICE_IOEVENTFD_64: u32 = 8;
pub const VFIO_DEVICE_IOEVENTFD_SIZE_MASK: u32 = 15;
pub const VFIO_IOMMU_INFO_PGSIZES: u32 = 1;
pub const VFIO_DMA_MAP_FLAG_READ: u32 = 1;
pub const VFIO_DMA_MAP_FLAG_WRITE: u32 = 2;
pub const VFIO_IOMMU_SPAPR_INFO_DDW: u32 = 1;
pub const VFIO_EEH_PE_DISABLE: u32 = 0;
pub const VFIO_EEH_PE_ENABLE: u32 = 1;
pub const VFIO_EEH_PE_UNFREEZE_IO: u32 = 2;
pub const VFIO_EEH_PE_UNFREEZE_DMA: u32 = 3;
pub const VFIO_EEH_PE_GET_STATE: u32 = 4;
pub const VFIO_EEH_PE_STATE_NORMAL: u32 = 0;
pub const VFIO_EEH_PE_STATE_RESET: u32 = 1;
pub const VFIO_EEH_PE_STATE_STOPPED: u32 = 2;
pub const VFIO_EEH_PE_STATE_STOPPED_DMA: u32 = 4;
pub const VFIO_EEH_PE_STATE_UNAVAIL: u32 = 5;
pub const VFIO_EEH_PE_RESET_DEACTIVATE: u32 = 5;
pub const VFIO_EEH_PE_RESET_HOT: u32 = 6;
pub const VFIO_EEH_PE_RESET_FUNDAMENTAL: u32 = 7;
pub const VFIO_EEH_PE_CONFIGURE: u32 = 8;
pub const VFIO_EEH_PE_INJECT_ERR: u32 = 9;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fd_set"][::std::mem::size_of::<__kernel_fd_set>() - 128usize];
    ["Alignment of __kernel_fd_set"][::std::mem::align_of::<__kernel_fd_set>() - 8usize];
    ["Offset of field: __kernel_fd_set::fds_bits"]
        [::std::mem::offset_of!(__kernel_fd_set, fds_bits) - 0usize];
};
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fsid_t"][::std::mem::size_of::<__kernel_fsid_t>() - 8usize];
    ["Alignment of __kernel_fsid_t"][::std::mem::align_of::<__kernel_fsid_t>() - 4usize];
    ["Offset of field: __kernel_fsid_t::val"]
        [::std::mem::offset_of!(__kernel_fsid_t, val) - 0usize];
};
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_info_cap_header {
    pub id: __u16,
    pub version: __u16,
    pub next: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_info_cap_header"][::std::mem::size_of::<vfio_info_cap_header>() - 8usize];
    ["Alignment of vfio_info_cap_header"][::std::mem::align_of::<vfio_info_cap_header>() - 4usize];
    ["Offset of field: vfio_info_cap_header::id"]
        [::std::mem::offset_of!(vfio_info_cap_header, id) - 0usize];
    ["Offset of field: vfio_info_cap_header::version"]
        [::std::mem::offset_of!(vfio_info_cap_header, version) - 2usize];
    ["Offset of field: vfio_info_cap_header::next"]
        [::std::mem::offset_of!(vfio_info_cap_header, next) - 4usize];
};
#[doc = " VFIO_GROUP_GET_STATUS - _IOR(VFIO_TYPE, VFIO_BASE + 3,\n\t\t\t\t\t\tstruct vfio_group_status)\n\n Retrieve information about the group.  Fills in provided\n struct vfio_group_info.  Caller sets argsz.\n Return: 0 on succes, -errno on failure.\n Availability: Always"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_group_status {
    pub argsz: __u32,
    pub flags: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_group_status"][::std::mem::size_of::<vfio_group_status>() - 8usize];
    ["Alignment of vfio_group_status"][::std::mem::align_of::<vfio_group_status>() - 4usize];
    ["Offset of field: vfio_group_status::argsz"]
        [::std::mem::offset_of!(vfio_group_status, argsz) - 0usize];
    ["Offset of field: vfio_group_status::flags"]
        [::std::mem::offset_of!(vfio_group_status, flags) - 4usize];
};
#[doc = " VFIO_DEVICE_GET_INFO - _IOR(VFIO_TYPE, VFIO_BASE + 7,\n\t\t\t\t\t\tstruct vfio_device_info)\n\n Retrieve information about the device.  Fills in provided\n struct vfio_device_info.  Caller sets argsz.\n Return: 0 on success, -errno on failure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_device_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub num_regions: __u32,
    pub num_irqs: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_device_info"][::std::mem::size_of::<vfio_device_info>() - 16usize];
    ["Alignment of vfio_device_info"][::std::mem::align_of::<vfio_device_info>() - 4usize];
    ["Offset of field: vfio_device_info::argsz"]
        [::std::mem::offset_of!(vfio_device_info, argsz) - 0usize];
    ["Offset of field: vfio_device_info::flags"]
        [::std::mem::offset_of!(vfio_device_info, flags) - 4usize];
    ["Offset of field: vfio_device_info::num_regions"]
        [::std::mem::offset_of!(vfio_device_info, num_regions) - 8usize];
    ["Offset of field: vfio_device_info::num_irqs"]
        [::std::mem::offset_of!(vfio_device_info, num_irqs) - 12usize];
};
#[doc = " VFIO_DEVICE_GET_REGION_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 8,\n\t\t\t\t       struct vfio_region_info)\n\n Retrieve information about a device region.  Caller provides\n struct vfio_region_info with index value set.  Caller sets argsz.\n Implementation of region mapping is bus driver specific.  This is\n intended to describe MMIO, I/O port, as well as bus specific\n regions (ex. PCI config space).  Zero sized regions may be used\n to describe unimplemented regions (ex. unimplemented PCI BARs).\n Return: 0 on success, -errno on failure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_region_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub cap_offset: __u32,
    pub size: __u64,
    pub offset: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_region_info"][::std::mem::size_of::<vfio_region_info>() - 32usize];
    ["Alignment of vfio_region_info"][::std::mem::align_of::<vfio_region_info>() - 8usize];
    ["Offset of field: vfio_region_info::argsz"]
        [::std::mem::offset_of!(vfio_region_info, argsz) - 0usize];
    ["Offset of field: vfio_region_info::flags"]
        [::std::mem::offset_of!(vfio_region_info, flags) - 4usize];
    ["Offset of field: vfio_region_info::index"]
        [::std::mem::offset_of!(vfio_region_info, index) - 8usize];
    ["Offset of field: vfio_region_info::cap_offset"]
        [::std::mem::offset_of!(vfio_region_info, cap_offset) - 12usize];
    ["Offset of field: vfio_region_info::size"]
        [::std::mem::offset_of!(vfio_region_info, size) - 16usize];
    ["Offset of field: vfio_region_info::offset"]
        [::std::mem::offset_of!(vfio_region_info, offset) - 24usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_region_sparse_mmap_area {
    pub offset: __u64,
    pub size: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_region_sparse_mmap_area"]
        [::std::mem::size_of::<vfio_region_sparse_mmap_area>() - 16usize];
    ["Alignment of vfio_region_sparse_mmap_area"]
        [::std::mem::align_of::<vfio_region_sparse_mmap_area>() - 8usize];
    ["Offset of field: vfio_region_sparse_mmap_area::offset"]
        [::std::mem::offset_of!(vfio_region_sparse_mmap_area, offset) - 0usize];
    ["Offset of field: vfio_region_sparse_mmap_area::size"]
        [::std::mem::offset_of!(vfio_region_sparse_mmap_area, size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default)]
pub struct vfio_region_info_cap_sparse_mmap {
    pub header: vfio_info_cap_header,
    pub nr_areas: __u32,
    pub reserved: __u32,
    pub areas: __IncompleteArrayField<vfio_region_sparse_mmap_area>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_region_info_cap_sparse_mmap"]
        [::std::mem::size_of::<vfio_region_info_cap_sparse_mmap>() - 16usize];
    ["Alignment of vfio_region_info_cap_sparse_mmap"]
        [::std::mem::align_of::<vfio_region_info_cap_sparse_mmap>() - 8usize];
    ["Offset of field: vfio_region_info_cap_sparse_mmap::header"]
        [::std::mem::offset_of!(vfio_region_info_cap_sparse_mmap, header) - 0usize];
    ["Offset of field: vfio_region_info_cap_sparse_mmap::nr_areas"]
        [::std::mem::offset_of!(vfio_region_info_cap_sparse_mmap, nr_areas) - 8usize];
    ["Offset of field: vfio_region_info_cap_sparse_mmap::reserved"]
        [::std::mem::offset_of!(vfio_region_info_cap_sparse_mmap, reserved) - 12usize];
    ["Offset of field: vfio_region_info_cap_sparse_mmap::areas"]
        [::std::mem::offset_of!(vfio_region_info_cap_sparse_mmap, areas) - 16usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_region_info_cap_type {
    pub header: vfio_info_cap_header,
    pub type_: __u32,
    pub subtype: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_region_info_cap_type"]
        [::std::mem::size_of::<vfio_region_info_cap_type>() - 16usize];
    ["Alignment of vfio_region_info_cap_type"]
        [::std::mem::align_of::<vfio_region_info_cap_type>() - 4usize];
    ["Offset of field: vfio_region_info_cap_type::header"]
        [::std::mem::offset_of!(vfio_region_info_cap_type, header) - 0usize];
    ["Offset of field: vfio_region_info_cap_type::type_"]
        [::std::mem::offset_of!(vfio_region_info_cap_type, type_) - 8usize];
    ["Offset of field: vfio_region_info_cap_type::subtype"]
        [::std::mem::offset_of!(vfio_region_info_cap_type, subtype) - 12usize];
};
#[doc = " struct vfio_region_gfx_edid - EDID region layout.\n\n Set display link state and EDID blob.\n\n The EDID blob has monitor information such as brand, name, serial\n number, physical size, supported video modes and more.\n\n This special region allows userspace (typically qemu) set a virtual\n EDID for the virtual monitor, which allows a flexible display\n configuration.\n\n For the edid blob spec look here:\n    https://en.wikipedia.org/wiki/Extended_Display_Identification_Data\n\n On linux systems you can find the EDID blob in sysfs:\n    /sys/class/drm/${card}/${connector}/edid\n\n You can use the edid-decode ulility (comes with xorg-x11-utils) to\n decode the EDID blob.\n\n @edid_offset: location of the edid blob, relative to the\n               start of the region (readonly).\n @edid_max_size: max size of the edid blob (readonly).\n @edid_size: actual edid size (read/write).\n @link_state: display link state (read/write).\n VFIO_DEVICE_GFX_LINK_STATE_UP: Monitor is turned on.\n VFIO_DEVICE_GFX_LINK_STATE_DOWN: Monitor is turned off.\n @max_xres: max display width (0 == no limitation, readonly).\n @max_yres: max display height (0 == no limitation, readonly).\n\n EDID update protocol:\n   (1) set link-state to down.\n   (2) update edid blob and size.\n   (3) set link-state to up."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_region_gfx_edid {
    pub edid_offset: __u32,
    pub edid_max_size: __u32,
    pub edid_size: __u32,
    pub max_xres: __u32,
    pub max_yres: __u32,
    pub link_state: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_region_gfx_edid"][::std::mem::size_of::<vfio_region_gfx_edid>() - 24usize];
    ["Alignment of vfio_region_gfx_edid"][::std::mem::align_of::<vfio_region_gfx_edid>() - 4usize];
    ["Offset of field: vfio_region_gfx_edid::edid_offset"]
        [::std::mem::offset_of!(vfio_region_gfx_edid, edid_offset) - 0usize];
    ["Offset of field: vfio_region_gfx_edid::edid_max_size"]
        [::std::mem::offset_of!(vfio_region_gfx_edid, edid_max_size) - 4usize];
    ["Offset of field: vfio_region_gfx_edid::edid_size"]
        [::std::mem::offset_of!(vfio_region_gfx_edid, edid_size) - 8usize];
    ["Offset of field: vfio_region_gfx_edid::max_xres"]
        [::std::mem::offset_of!(vfio_region_gfx_edid, max_xres) - 12usize];
    ["Offset of field: vfio_region_gfx_edid::max_yres"]
        [::std::mem::offset_of!(vfio_region_gfx_edid, max_yres) - 16usize];
    ["Offset of field: vfio_region_gfx_edid::link_state"]
        [::std::mem::offset_of!(vfio_region_gfx_edid, link_state) - 20usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_region_info_cap_nvlink2_ssatgt {
    pub header: vfio_info_cap_header,
    pub tgt: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_region_info_cap_nvlink2_ssatgt"]
        [::std::mem::size_of::<vfio_region_info_cap_nvlink2_ssatgt>() - 16usize];
    ["Alignment of vfio_region_info_cap_nvlink2_ssatgt"]
        [::std::mem::align_of::<vfio_region_info_cap_nvlink2_ssatgt>() - 8usize];
    ["Offset of field: vfio_region_info_cap_nvlink2_ssatgt::header"]
        [::std::mem::offset_of!(vfio_region_info_cap_nvlink2_ssatgt, header) - 0usize];
    ["Offset of field: vfio_region_info_cap_nvlink2_ssatgt::tgt"]
        [::std::mem::offset_of!(vfio_region_info_cap_nvlink2_ssatgt, tgt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_region_info_cap_nvlink2_lnkspd {
    pub header: vfio_info_cap_header,
    pub link_speed: __u32,
    pub __pad: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_region_info_cap_nvlink2_lnkspd"]
        [::std::mem::size_of::<vfio_region_info_cap_nvlink2_lnkspd>() - 16usize];
    ["Alignment of vfio_region_info_cap_nvlink2_lnkspd"]
        [::std::mem::align_of::<vfio_region_info_cap_nvlink2_lnkspd>() - 4usize];
    ["Offset of field: vfio_region_info_cap_nvlink2_lnkspd::header"]
        [::std::mem::offset_of!(vfio_region_info_cap_nvlink2_lnkspd, header) - 0usize];
    ["Offset of field: vfio_region_info_cap_nvlink2_lnkspd::link_speed"]
        [::std::mem::offset_of!(vfio_region_info_cap_nvlink2_lnkspd, link_speed) - 8usize];
    ["Offset of field: vfio_region_info_cap_nvlink2_lnkspd::__pad"]
        [::std::mem::offset_of!(vfio_region_info_cap_nvlink2_lnkspd, __pad) - 12usize];
};
#[doc = " VFIO_DEVICE_GET_IRQ_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 9,\n\t\t\t\t    struct vfio_irq_info)\n\n Retrieve information about a device IRQ.  Caller provides\n struct vfio_irq_info with index value set.  Caller sets argsz.\n Implementation of IRQ mapping is bus driver specific.  Indexes\n using multiple IRQs are primarily intended to support MSI-like\n interrupt blocks.  Zero count irq blocks may be used to describe\n unimplemented interrupt types.\n\n The EVENTFD flag indicates the interrupt index supports eventfd based\n signaling.\n\n The MASKABLE flags indicates the index supports MASK and UNMASK\n actions described below.\n\n AUTOMASKED indicates that after signaling, the interrupt line is\n automatically masked by VFIO and the user needs to unmask the line\n to receive new interrupts.  This is primarily intended to distinguish\n level triggered interrupts.\n\n The NORESIZE flag indicates that the interrupt lines within the index\n are setup as a set and new subindexes cannot be enabled without first\n disabling the entire index.  This is used for interrupts like PCI MSI\n and MSI-X where the driver may only use a subset of the available\n indexes, but VFIO needs to enable a specific number of vectors\n upfront.  In the case of MSI-X, where the user can enable MSI-X and\n then add and unmask vectors, it's up to userspace to make the decision\n whether to allocate the maximum supported number of vectors or tear\n down setup and incrementally increase the vectors as each is enabled."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_irq_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub count: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_irq_info"][::std::mem::size_of::<vfio_irq_info>() - 16usize];
    ["Alignment of vfio_irq_info"][::std::mem::align_of::<vfio_irq_info>() - 4usize];
    ["Offset of field: vfio_irq_info::argsz"]
        [::std::mem::offset_of!(vfio_irq_info, argsz) - 0usize];
    ["Offset of field: vfio_irq_info::flags"]
        [::std::mem::offset_of!(vfio_irq_info, flags) - 4usize];
    ["Offset of field: vfio_irq_info::index"]
        [::std::mem::offset_of!(vfio_irq_info, index) - 8usize];
    ["Offset of field: vfio_irq_info::count"]
        [::std::mem::offset_of!(vfio_irq_info, count) - 12usize];
};
#[doc = " VFIO_DEVICE_SET_IRQS - _IOW(VFIO_TYPE, VFIO_BASE + 10, struct vfio_irq_set)\n\n Set signaling, masking, and unmasking of interrupts.  Caller provides\n struct vfio_irq_set with all fields set.  'start' and 'count' indicate\n the range of subindexes being specified.\n\n The DATA flags specify the type of data provided.  If DATA_NONE, the\n operation performs the specified action immediately on the specified\n interrupt(s).  For example, to unmask AUTOMASKED interrupt [0,0]:\n flags = (DATA_NONE|ACTION_UNMASK), index = 0, start = 0, count = 1.\n\n DATA_BOOL allows sparse support for the same on arrays of interrupts.\n For example, to mask interrupts [0,1] and [0,3] (but not [0,2]):\n flags = (DATA_BOOL|ACTION_MASK), index = 0, start = 1, count = 3,\n data = {1,0,1}\n\n DATA_EVENTFD binds the specified ACTION to the provided __s32 eventfd.\n A value of -1 can be used to either de-assign interrupts if already\n assigned or skip un-assigned interrupts.  For example, to set an eventfd\n to be trigger for interrupts [0,0] and [0,2]:\n flags = (DATA_EVENTFD|ACTION_TRIGGER), index = 0, start = 0, count = 3,\n data = {fd1, -1, fd2}\n If index [0,1] is previously set, two count = 1 ioctls calls would be\n required to set [0,0] and [0,2] without changing [0,1].\n\n Once a signaling mechanism is set, DATA_BOOL or DATA_NONE can be used\n with ACTION_TRIGGER to perform kernel level interrupt loopback testing\n from userspace (ie. simulate hardware triggering).\n\n Setting of an event triggering mechanism to userspace for ACTION_TRIGGER\n enables the interrupt index for the device.  Individual subindex interrupts\n can be disabled using the -1 value for DATA_EVENTFD or the index can be\n disabled as a whole with: flags = (DATA_NONE|ACTION_TRIGGER), count = 0.\n\n Note that ACTION_[UN]MASK specify user->kernel signaling (irqfds) while\n ACTION_TRIGGER specifies kernel->user signaling."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct vfio_irq_set {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub start: __u32,
    pub count: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_irq_set"][::std::mem::size_of::<vfio_irq_set>() - 20usize];
    ["Alignment of vfio_irq_set"][::std::mem::align_of::<vfio_irq_set>() - 4usize];
    ["Offset of field: vfio_irq_set::argsz"][::std::mem::offset_of!(vfio_irq_set, argsz) - 0usize];
    ["Offset of field: vfio_irq_set::flags"][::std::mem::offset_of!(vfio_irq_set, flags) - 4usize];
    ["Offset of field: vfio_irq_set::index"][::std::mem::offset_of!(vfio_irq_set, index) - 8usize];
    ["Offset of field: vfio_irq_set::start"][::std::mem::offset_of!(vfio_irq_set, start) - 12usize];
    ["Offset of field: vfio_irq_set::count"][::std::mem::offset_of!(vfio_irq_set, count) - 16usize];
    ["Offset of field: vfio_irq_set::data"][::std::mem::offset_of!(vfio_irq_set, data) - 20usize];
};
pub const VFIO_PCI_BAR0_REGION_INDEX: _bindgen_ty_1 = 0;
pub const VFIO_PCI_BAR1_REGION_INDEX: _bindgen_ty_1 = 1;
pub const VFIO_PCI_BAR2_REGION_INDEX: _bindgen_ty_1 = 2;
pub const VFIO_PCI_BAR3_REGION_INDEX: _bindgen_ty_1 = 3;
pub const VFIO_PCI_BAR4_REGION_INDEX: _bindgen_ty_1 = 4;
pub const VFIO_PCI_BAR5_REGION_INDEX: _bindgen_ty_1 = 5;
pub const VFIO_PCI_ROM_REGION_INDEX: _bindgen_ty_1 = 6;
pub const VFIO_PCI_CONFIG_REGION_INDEX: _bindgen_ty_1 = 7;
pub const VFIO_PCI_VGA_REGION_INDEX: _bindgen_ty_1 = 8;
pub const VFIO_PCI_NUM_REGIONS: _bindgen_ty_1 = 9;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const VFIO_PCI_INTX_IRQ_INDEX: _bindgen_ty_2 = 0;
pub const VFIO_PCI_MSI_IRQ_INDEX: _bindgen_ty_2 = 1;
pub const VFIO_PCI_MSIX_IRQ_INDEX: _bindgen_ty_2 = 2;
pub const VFIO_PCI_ERR_IRQ_INDEX: _bindgen_ty_2 = 3;
pub const VFIO_PCI_REQ_IRQ_INDEX: _bindgen_ty_2 = 4;
pub const VFIO_PCI_NUM_IRQS: _bindgen_ty_2 = 5;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const VFIO_CCW_CONFIG_REGION_INDEX: _bindgen_ty_3 = 0;
pub const VFIO_CCW_NUM_REGIONS: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const VFIO_CCW_IO_IRQ_INDEX: _bindgen_ty_4 = 0;
pub const VFIO_CCW_NUM_IRQS: _bindgen_ty_4 = 1;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = " VFIO_DEVICE_GET_PCI_HOT_RESET_INFO - _IORW(VFIO_TYPE, VFIO_BASE + 12,\n\t\t\t\t\t      struct vfio_pci_hot_reset_info)\n\n Return: 0 on success, -errno on failure:\n\t-enospc = insufficient buffer, -enodev = unsupported for device."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_pci_dependent_device {
    pub group_id: __u32,
    pub segment: __u16,
    pub bus: __u8,
    pub devfn: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_pci_dependent_device"]
        [::std::mem::size_of::<vfio_pci_dependent_device>() - 8usize];
    ["Alignment of vfio_pci_dependent_device"]
        [::std::mem::align_of::<vfio_pci_dependent_device>() - 4usize];
    ["Offset of field: vfio_pci_dependent_device::group_id"]
        [::std::mem::offset_of!(vfio_pci_dependent_device, group_id) - 0usize];
    ["Offset of field: vfio_pci_dependent_device::segment"]
        [::std::mem::offset_of!(vfio_pci_dependent_device, segment) - 4usize];
    ["Offset of field: vfio_pci_dependent_device::bus"]
        [::std::mem::offset_of!(vfio_pci_dependent_device, bus) - 6usize];
    ["Offset of field: vfio_pci_dependent_device::devfn"]
        [::std::mem::offset_of!(vfio_pci_dependent_device, devfn) - 7usize];
};
#[repr(C)]
#[derive(Debug, Default)]
pub struct vfio_pci_hot_reset_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub count: __u32,
    pub devices: __IncompleteArrayField<vfio_pci_dependent_device>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_pci_hot_reset_info"][::std::mem::size_of::<vfio_pci_hot_reset_info>() - 12usize];
    ["Alignment of vfio_pci_hot_reset_info"]
        [::std::mem::align_of::<vfio_pci_hot_reset_info>() - 4usize];
    ["Offset of field: vfio_pci_hot_reset_info::argsz"]
        [::std::mem::offset_of!(vfio_pci_hot_reset_info, argsz) - 0usize];
    ["Offset of field: vfio_pci_hot_reset_info::flags"]
        [::std::mem::offset_of!(vfio_pci_hot_reset_info, flags) - 4usize];
    ["Offset of field: vfio_pci_hot_reset_info::count"]
        [::std::mem::offset_of!(vfio_pci_hot_reset_info, count) - 8usize];
    ["Offset of field: vfio_pci_hot_reset_info::devices"]
        [::std::mem::offset_of!(vfio_pci_hot_reset_info, devices) - 12usize];
};
#[doc = " VFIO_DEVICE_PCI_HOT_RESET - _IOW(VFIO_TYPE, VFIO_BASE + 13,\n\t\t\t\t    struct vfio_pci_hot_reset)\n\n Return: 0 on success, -errno on failure."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct vfio_pci_hot_reset {
    pub argsz: __u32,
    pub flags: __u32,
    pub count: __u32,
    pub group_fds: __IncompleteArrayField<__s32>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_pci_hot_reset"][::std::mem::size_of::<vfio_pci_hot_reset>() - 12usize];
    ["Alignment of vfio_pci_hot_reset"][::std::mem::align_of::<vfio_pci_hot_reset>() - 4usize];
    ["Offset of field: vfio_pci_hot_reset::argsz"]
        [::std::mem::offset_of!(vfio_pci_hot_reset, argsz) - 0usize];
    ["Offset of field: vfio_pci_hot_reset::flags"]
        [::std::mem::offset_of!(vfio_pci_hot_reset, flags) - 4usize];
    ["Offset of field: vfio_pci_hot_reset::count"]
        [::std::mem::offset_of!(vfio_pci_hot_reset, count) - 8usize];
    ["Offset of field: vfio_pci_hot_reset::group_fds"]
        [::std::mem::offset_of!(vfio_pci_hot_reset, group_fds) - 12usize];
};
#[doc = " VFIO_DEVICE_QUERY_GFX_PLANE - _IOW(VFIO_TYPE, VFIO_BASE + 14,\n                                    struct vfio_device_query_gfx_plane)\n\n Set the drm_plane_type and flags, then retrieve the gfx plane info.\n\n flags supported:\n - VFIO_GFX_PLANE_TYPE_PROBE and VFIO_GFX_PLANE_TYPE_DMABUF are set\n   to ask if the mdev supports dma-buf. 0 on support, -EINVAL on no\n   support for dma-buf.\n - VFIO_GFX_PLANE_TYPE_PROBE and VFIO_GFX_PLANE_TYPE_REGION are set\n   to ask if the mdev supports region. 0 on support, -EINVAL on no\n   support for region.\n - VFIO_GFX_PLANE_TYPE_DMABUF or VFIO_GFX_PLANE_TYPE_REGION is set\n   with each call to query the plane info.\n - Others are invalid and return -EINVAL.\n\n Note:\n 1. Plane could be disabled by guest. In that case, success will be\n    returned with zero-initialized drm_format, size, width and height\n    fields.\n 2. x_hot/y_hot is set to 0xFFFFFFFF if no hotspot information available\n\n Return: 0 on success, -errno on other failure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfio_device_gfx_plane_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub drm_plane_type: __u32,
    pub drm_format: __u32,
    pub drm_format_mod: __u64,
    pub width: __u32,
    pub height: __u32,
    pub stride: __u32,
    pub size: __u32,
    pub x_pos: __u32,
    pub y_pos: __u32,
    pub x_hot: __u32,
    pub y_hot: __u32,
    pub __bindgen_anon_1: vfio_device_gfx_plane_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vfio_device_gfx_plane_info__bindgen_ty_1 {
    pub region_index: __u32,
    pub dmabuf_id: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_device_gfx_plane_info__bindgen_ty_1"]
        [::std::mem::size_of::<vfio_device_gfx_plane_info__bindgen_ty_1>() - 4usize];
    ["Alignment of vfio_device_gfx_plane_info__bindgen_ty_1"]
        [::std::mem::align_of::<vfio_device_gfx_plane_info__bindgen_ty_1>() - 4usize];
    ["Offset of field: vfio_device_gfx_plane_info__bindgen_ty_1::region_index"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info__bindgen_ty_1, region_index) - 0usize];
    ["Offset of field: vfio_device_gfx_plane_info__bindgen_ty_1::dmabuf_id"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info__bindgen_ty_1, dmabuf_id) - 0usize];
};
impl Default for vfio_device_gfx_plane_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_device_gfx_plane_info"]
        [::std::mem::size_of::<vfio_device_gfx_plane_info>() - 64usize];
    ["Alignment of vfio_device_gfx_plane_info"]
        [::std::mem::align_of::<vfio_device_gfx_plane_info>() - 8usize];
    ["Offset of field: vfio_device_gfx_plane_info::argsz"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, argsz) - 0usize];
    ["Offset of field: vfio_device_gfx_plane_info::flags"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, flags) - 4usize];
    ["Offset of field: vfio_device_gfx_plane_info::drm_plane_type"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, drm_plane_type) - 8usize];
    ["Offset of field: vfio_device_gfx_plane_info::drm_format"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, drm_format) - 12usize];
    ["Offset of field: vfio_device_gfx_plane_info::drm_format_mod"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, drm_format_mod) - 16usize];
    ["Offset of field: vfio_device_gfx_plane_info::width"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, width) - 24usize];
    ["Offset of field: vfio_device_gfx_plane_info::height"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, height) - 28usize];
    ["Offset of field: vfio_device_gfx_plane_info::stride"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, stride) - 32usize];
    ["Offset of field: vfio_device_gfx_plane_info::size"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, size) - 36usize];
    ["Offset of field: vfio_device_gfx_plane_info::x_pos"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, x_pos) - 40usize];
    ["Offset of field: vfio_device_gfx_plane_info::y_pos"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, y_pos) - 44usize];
    ["Offset of field: vfio_device_gfx_plane_info::x_hot"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, x_hot) - 48usize];
    ["Offset of field: vfio_device_gfx_plane_info::y_hot"]
        [::std::mem::offset_of!(vfio_device_gfx_plane_info, y_hot) - 52usize];
};
impl Default for vfio_device_gfx_plane_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " VFIO_DEVICE_IOEVENTFD - _IOW(VFIO_TYPE, VFIO_BASE + 16,\n                              struct vfio_device_ioeventfd)\n\n Perform a write to the device at the specified device fd offset, with\n the specified data and width when the provided eventfd is triggered.\n vfio bus drivers may not support this for all regions, for all widths,\n or at all.  vfio-pci currently only enables support for BAR regions,\n excluding the MSI-X vector table.\n\n Return: 0 on success, -errno on failure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_device_ioeventfd {
    pub argsz: __u32,
    pub flags: __u32,
    pub offset: __u64,
    pub data: __u64,
    pub fd: __s32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_device_ioeventfd"][::std::mem::size_of::<vfio_device_ioeventfd>() - 32usize];
    ["Alignment of vfio_device_ioeventfd"]
        [::std::mem::align_of::<vfio_device_ioeventfd>() - 8usize];
    ["Offset of field: vfio_device_ioeventfd::argsz"]
        [::std::mem::offset_of!(vfio_device_ioeventfd, argsz) - 0usize];
    ["Offset of field: vfio_device_ioeventfd::flags"]
        [::std::mem::offset_of!(vfio_device_ioeventfd, flags) - 4usize];
    ["Offset of field: vfio_device_ioeventfd::offset"]
        [::std::mem::offset_of!(vfio_device_ioeventfd, offset) - 8usize];
    ["Offset of field: vfio_device_ioeventfd::data"]
        [::std::mem::offset_of!(vfio_device_ioeventfd, data) - 16usize];
    ["Offset of field: vfio_device_ioeventfd::fd"]
        [::std::mem::offset_of!(vfio_device_ioeventfd, fd) - 24usize];
};
#[doc = " VFIO_IOMMU_GET_INFO - _IOR(VFIO_TYPE, VFIO_BASE + 12, struct vfio_iommu_info)\n\n Retrieve information about the IOMMU object. Fills in provided\n struct vfio_iommu_info. Caller sets argsz.\n\n XXX Should we do these by CHECK_EXTENSION too?"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_iommu_type1_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub iova_pgsizes: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_iommu_type1_info"][::std::mem::size_of::<vfio_iommu_type1_info>() - 16usize];
    ["Alignment of vfio_iommu_type1_info"]
        [::std::mem::align_of::<vfio_iommu_type1_info>() - 8usize];
    ["Offset of field: vfio_iommu_type1_info::argsz"]
        [::std::mem::offset_of!(vfio_iommu_type1_info, argsz) - 0usize];
    ["Offset of field: vfio_iommu_type1_info::flags"]
        [::std::mem::offset_of!(vfio_iommu_type1_info, flags) - 4usize];
    ["Offset of field: vfio_iommu_type1_info::iova_pgsizes"]
        [::std::mem::offset_of!(vfio_iommu_type1_info, iova_pgsizes) - 8usize];
};
#[doc = " VFIO_IOMMU_MAP_DMA - _IOW(VFIO_TYPE, VFIO_BASE + 13, struct vfio_dma_map)\n\n Map process virtual addresses to IO virtual addresses using the\n provided struct vfio_dma_map. Caller sets argsz. READ &/ WRITE required."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_iommu_type1_dma_map {
    pub argsz: __u32,
    pub flags: __u32,
    pub vaddr: __u64,
    pub iova: __u64,
    pub size: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_iommu_type1_dma_map"]
        [::std::mem::size_of::<vfio_iommu_type1_dma_map>() - 32usize];
    ["Alignment of vfio_iommu_type1_dma_map"]
        [::std::mem::align_of::<vfio_iommu_type1_dma_map>() - 8usize];
    ["Offset of field: vfio_iommu_type1_dma_map::argsz"]
        [::std::mem::offset_of!(vfio_iommu_type1_dma_map, argsz) - 0usize];
    ["Offset of field: vfio_iommu_type1_dma_map::flags"]
        [::std::mem::offset_of!(vfio_iommu_type1_dma_map, flags) - 4usize];
    ["Offset of field: vfio_iommu_type1_dma_map::vaddr"]
        [::std::mem::offset_of!(vfio_iommu_type1_dma_map, vaddr) - 8usize];
    ["Offset of field: vfio_iommu_type1_dma_map::iova"]
        [::std::mem::offset_of!(vfio_iommu_type1_dma_map, iova) - 16usize];
    ["Offset of field: vfio_iommu_type1_dma_map::size"]
        [::std::mem::offset_of!(vfio_iommu_type1_dma_map, size) - 24usize];
};
#[doc = " VFIO_IOMMU_UNMAP_DMA - _IOWR(VFIO_TYPE, VFIO_BASE + 14,\n\t\t\t\t\t\t\tstruct vfio_dma_unmap)\n\n Unmap IO virtual addresses using the provided struct vfio_dma_unmap.\n Caller sets argsz.  The actual unmapped size is returned in the size\n field.  No guarantee is made to the user that arbitrary unmaps of iova\n or size different from those used in the original mapping call will\n succeed."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_iommu_type1_dma_unmap {
    pub argsz: __u32,
    pub flags: __u32,
    pub iova: __u64,
    pub size: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_iommu_type1_dma_unmap"]
        [::std::mem::size_of::<vfio_iommu_type1_dma_unmap>() - 24usize];
    ["Alignment of vfio_iommu_type1_dma_unmap"]
        [::std::mem::align_of::<vfio_iommu_type1_dma_unmap>() - 8usize];
    ["Offset of field: vfio_iommu_type1_dma_unmap::argsz"]
        [::std::mem::offset_of!(vfio_iommu_type1_dma_unmap, argsz) - 0usize];
    ["Offset of field: vfio_iommu_type1_dma_unmap::flags"]
        [::std::mem::offset_of!(vfio_iommu_type1_dma_unmap, flags) - 4usize];
    ["Offset of field: vfio_iommu_type1_dma_unmap::iova"]
        [::std::mem::offset_of!(vfio_iommu_type1_dma_unmap, iova) - 8usize];
    ["Offset of field: vfio_iommu_type1_dma_unmap::size"]
        [::std::mem::offset_of!(vfio_iommu_type1_dma_unmap, size) - 16usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_iommu_spapr_tce_ddw_info {
    pub pgsizes: __u64,
    pub max_dynamic_windows_supported: __u32,
    pub levels: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_iommu_spapr_tce_ddw_info"]
        [::std::mem::size_of::<vfio_iommu_spapr_tce_ddw_info>() - 16usize];
    ["Alignment of vfio_iommu_spapr_tce_ddw_info"]
        [::std::mem::align_of::<vfio_iommu_spapr_tce_ddw_info>() - 8usize];
    ["Offset of field: vfio_iommu_spapr_tce_ddw_info::pgsizes"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_ddw_info, pgsizes) - 0usize];
    ["Offset of field: vfio_iommu_spapr_tce_ddw_info::max_dynamic_windows_supported"][::std::mem::offset_of!(
        vfio_iommu_spapr_tce_ddw_info,
        max_dynamic_windows_supported
    ) - 8usize];
    ["Offset of field: vfio_iommu_spapr_tce_ddw_info::levels"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_ddw_info, levels) - 12usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_iommu_spapr_tce_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub dma32_window_start: __u32,
    pub dma32_window_size: __u32,
    pub ddw: vfio_iommu_spapr_tce_ddw_info,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_iommu_spapr_tce_info"]
        [::std::mem::size_of::<vfio_iommu_spapr_tce_info>() - 32usize];
    ["Alignment of vfio_iommu_spapr_tce_info"]
        [::std::mem::align_of::<vfio_iommu_spapr_tce_info>() - 8usize];
    ["Offset of field: vfio_iommu_spapr_tce_info::argsz"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_info, argsz) - 0usize];
    ["Offset of field: vfio_iommu_spapr_tce_info::flags"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_info, flags) - 4usize];
    ["Offset of field: vfio_iommu_spapr_tce_info::dma32_window_start"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_info, dma32_window_start) - 8usize];
    ["Offset of field: vfio_iommu_spapr_tce_info::dma32_window_size"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_info, dma32_window_size) - 12usize];
    ["Offset of field: vfio_iommu_spapr_tce_info::ddw"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_info, ddw) - 16usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_eeh_pe_err {
    pub type_: __u32,
    pub func: __u32,
    pub addr: __u64,
    pub mask: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_eeh_pe_err"][::std::mem::size_of::<vfio_eeh_pe_err>() - 24usize];
    ["Alignment of vfio_eeh_pe_err"][::std::mem::align_of::<vfio_eeh_pe_err>() - 8usize];
    ["Offset of field: vfio_eeh_pe_err::type_"]
        [::std::mem::offset_of!(vfio_eeh_pe_err, type_) - 0usize];
    ["Offset of field: vfio_eeh_pe_err::func"]
        [::std::mem::offset_of!(vfio_eeh_pe_err, func) - 4usize];
    ["Offset of field: vfio_eeh_pe_err::addr"]
        [::std::mem::offset_of!(vfio_eeh_pe_err, addr) - 8usize];
    ["Offset of field: vfio_eeh_pe_err::mask"]
        [::std::mem::offset_of!(vfio_eeh_pe_err, mask) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfio_eeh_pe_op {
    pub argsz: __u32,
    pub flags: __u32,
    pub op: __u32,
    pub __bindgen_anon_1: vfio_eeh_pe_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vfio_eeh_pe_op__bindgen_ty_1 {
    pub err: vfio_eeh_pe_err,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_eeh_pe_op__bindgen_ty_1"]
        [::std::mem::size_of::<vfio_eeh_pe_op__bindgen_ty_1>() - 24usize];
    ["Alignment of vfio_eeh_pe_op__bindgen_ty_1"]
        [::std::mem::align_of::<vfio_eeh_pe_op__bindgen_ty_1>() - 8usize];
    ["Offset of field: vfio_eeh_pe_op__bindgen_ty_1::err"]
        [::std::mem::offset_of!(vfio_eeh_pe_op__bindgen_ty_1, err) - 0usize];
};
impl Default for vfio_eeh_pe_op__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_eeh_pe_op"][::std::mem::size_of::<vfio_eeh_pe_op>() - 40usize];
    ["Alignment of vfio_eeh_pe_op"][::std::mem::align_of::<vfio_eeh_pe_op>() - 8usize];
    ["Offset of field: vfio_eeh_pe_op::argsz"]
        [::std::mem::offset_of!(vfio_eeh_pe_op, argsz) - 0usize];
    ["Offset of field: vfio_eeh_pe_op::flags"]
        [::std::mem::offset_of!(vfio_eeh_pe_op, flags) - 4usize];
    ["Offset of field: vfio_eeh_pe_op::op"][::std::mem::offset_of!(vfio_eeh_pe_op, op) - 8usize];
};
impl Default for vfio_eeh_pe_op {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " VFIO_IOMMU_SPAPR_REGISTER_MEMORY - _IOW(VFIO_TYPE, VFIO_BASE + 17, struct vfio_iommu_spapr_register_memory)\n\n Registers user space memory where DMA is allowed. It pins\n user pages and does the locked memory accounting so\n subsequent VFIO_IOMMU_MAP_DMA/VFIO_IOMMU_UNMAP_DMA calls\n get faster."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_iommu_spapr_register_memory {
    pub argsz: __u32,
    pub flags: __u32,
    pub vaddr: __u64,
    pub size: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_iommu_spapr_register_memory"]
        [::std::mem::size_of::<vfio_iommu_spapr_register_memory>() - 24usize];
    ["Alignment of vfio_iommu_spapr_register_memory"]
        [::std::mem::align_of::<vfio_iommu_spapr_register_memory>() - 8usize];
    ["Offset of field: vfio_iommu_spapr_register_memory::argsz"]
        [::std::mem::offset_of!(vfio_iommu_spapr_register_memory, argsz) - 0usize];
    ["Offset of field: vfio_iommu_spapr_register_memory::flags"]
        [::std::mem::offset_of!(vfio_iommu_spapr_register_memory, flags) - 4usize];
    ["Offset of field: vfio_iommu_spapr_register_memory::vaddr"]
        [::std::mem::offset_of!(vfio_iommu_spapr_register_memory, vaddr) - 8usize];
    ["Offset of field: vfio_iommu_spapr_register_memory::size"]
        [::std::mem::offset_of!(vfio_iommu_spapr_register_memory, size) - 16usize];
};
#[doc = " VFIO_IOMMU_SPAPR_TCE_CREATE - _IOWR(VFIO_TYPE, VFIO_BASE + 19, struct vfio_iommu_spapr_tce_create)\n\n Creates an additional TCE table and programs it (sets a new DMA window)\n to every IOMMU group in the container. It receives page shift, window\n size and number of levels in the TCE table being created.\n\n It allocates and returns an offset on a PCI bus of the new DMA window."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_iommu_spapr_tce_create {
    pub argsz: __u32,
    pub flags: __u32,
    pub page_shift: __u32,
    pub __resv1: __u32,
    pub window_size: __u64,
    pub levels: __u32,
    pub __resv2: __u32,
    pub start_addr: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_iommu_spapr_tce_create"]
        [::std::mem::size_of::<vfio_iommu_spapr_tce_create>() - 40usize];
    ["Alignment of vfio_iommu_spapr_tce_create"]
        [::std::mem::align_of::<vfio_iommu_spapr_tce_create>() - 8usize];
    ["Offset of field: vfio_iommu_spapr_tce_create::argsz"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_create, argsz) - 0usize];
    ["Offset of field: vfio_iommu_spapr_tce_create::flags"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_create, flags) - 4usize];
    ["Offset of field: vfio_iommu_spapr_tce_create::page_shift"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_create, page_shift) - 8usize];
    ["Offset of field: vfio_iommu_spapr_tce_create::__resv1"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_create, __resv1) - 12usize];
    ["Offset of field: vfio_iommu_spapr_tce_create::window_size"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_create, window_size) - 16usize];
    ["Offset of field: vfio_iommu_spapr_tce_create::levels"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_create, levels) - 24usize];
    ["Offset of field: vfio_iommu_spapr_tce_create::__resv2"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_create, __resv2) - 28usize];
    ["Offset of field: vfio_iommu_spapr_tce_create::start_addr"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_create, start_addr) - 32usize];
};
#[doc = " VFIO_IOMMU_SPAPR_TCE_REMOVE - _IOW(VFIO_TYPE, VFIO_BASE + 20, struct vfio_iommu_spapr_tce_remove)\n\n Unprograms a TCE table from all groups in the container and destroys it.\n It receives a PCI bus offset as a window id."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vfio_iommu_spapr_tce_remove {
    pub argsz: __u32,
    pub flags: __u32,
    pub start_addr: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vfio_iommu_spapr_tce_remove"]
        [::std::mem::size_of::<vfio_iommu_spapr_tce_remove>() - 16usize];
    ["Alignment of vfio_iommu_spapr_tce_remove"]
        [::std::mem::align_of::<vfio_iommu_spapr_tce_remove>() - 8usize];
    ["Offset of field: vfio_iommu_spapr_tce_remove::argsz"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_remove, argsz) - 0usize];
    ["Offset of field: vfio_iommu_spapr_tce_remove::flags"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_remove, flags) - 4usize];
    ["Offset of field: vfio_iommu_spapr_tce_remove::start_addr"]
        [::std::mem::offset_of!(vfio_iommu_spapr_tce_remove, start_addr) - 8usize];
};
